{"title":"1 0-1背包","uid":"6cf5ad84fc4af74989856ae444b292c5","slug":"1 0-1背包","date":"2025-03-04T16:00:00.000Z","updated":"2025-03-07T03:41:51.512Z","comments":true,"path":"api/articles/1 0-1背包.json","keywords":null,"cover":null,"content":"<h2 id=\"题目描述\">题目描述</h2>\n<p>有 N件物品和一个容量是V的背包。每件物品只能使用一次。</p>\n<p>第i件物品的体积是 vi，价值是 wi。</p>\n<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>\n<p>输出最大价值。</p>\n<h5 id=\"输入样例\">输入样例</h5>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4 5</span><br><span class=\"line\">1 2</span><br><span class=\"line\">2 4</span><br><span class=\"line\">3 4</span><br><span class=\"line\">4 5</span><br></pre></td></tr></table></figure>\n<h5 id=\"输出样例\">输出样例</h5>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n<h2 id=\"原题链接\">原题链接</h2>\n<ul>\n<li><a href=\"https://www.acwing.com/problem/content/2/\">Acwing</a></li>\n</ul>\n<hr>\n<h2 id=\"解题思路\">解题思路</h2>\n<p>状态表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">状态是 当背包容量为 j 时， 前 i 个物品的选法。 </span><br><span class=\"line\"></span><br><span class=\"line\">f[i][j] 表示在所有选法中，背包所装物品的最大价值</span><br></pre></td></tr></table></figure>\n<p>状态转移：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">考虑到 容量为j，前i个物品的所有选法 = &#123;包含物品i ， 不包含物品i&#125;</span><br><span class=\"line\">f[i][j] = max (f[i - 1][j] , f[i - 1][j - w[i]] + v[i])</span><br></pre></td></tr></table></figure>\n<p>注意到，并不是所有的容量 j 都对应以上转移方程，当容量 j 小于 第 i 个物品的代价时 ，就减少了一种包含物品 i 的状态 ，因此并不需要计算max函数</p>\n<h2 id=\"代码\">代码</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e3</span><span class=\"number\">+10</span> ;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">int</span> f[N][N];</span><br><span class=\"line\"><span class=\"type\">int</span> w[N],v[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ;i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span> , &amp;w[i],&amp;v[i]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span> ; j &lt;= m ;j++)&#123;</span><br><span class=\"line\">            f[i][j] = f[i<span class=\"number\">-1</span>][j] ;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j &gt;= w[i]) f[i][j] = <span class=\"built_in\">max</span>(f[i][j] , f[i<span class=\"number\">-1</span>][j-w[i]] + v[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; f[n][m];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>算法的时间复杂度 O( n * m ) , 空间复杂度 O( n * m )     注意实际代码的dp数组开了N * N</p>\n<hr>\n<h2 id=\"优化\">优化</h2>\n<p>考虑将二维数组优化为一维</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e3</span><span class=\"number\">+10</span> ;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">int</span> f[N]; <span class=\"comment\">// f[N][N]</span></span><br><span class=\"line\"><span class=\"type\">int</span> w[N],v[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ;i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span> , &amp;w[i],&amp;v[i]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = m ; j &gt;= w[i] ;j--)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//f[i][j] = f[i-1][j] ;</span></span><br><span class=\"line\">            <span class=\"comment\">//if(j &gt;= w[i]) f[i][j] = max(f[i][j] , f[i-1][j-w[i]] + v[i]);</span></span><br><span class=\"line\">            f[j] = <span class=\"built_in\">max</span>(f[j] , f[j-w[i]] + v[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; f[m];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为什么可以用一维数组呢？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">考虑计算状态转移方程时 f[i][j] 的依赖关系 ，只可能依赖于上一行f[i - 1]的两个位置 </span><br><span class=\"line\">即正上方f[i - 1][j] 和 左上方 f[i - 1][j - w[i]]</span><br><span class=\"line\"></span><br><span class=\"line\">因此， 我们考虑一种变算变覆盖的可能， 我们用一维数组进行记录， 并保证从右到左更新数组， </span><br><span class=\"line\">这样一来， 我们在计算f[j]时， f[j - w[i]]仍然保持前一行的旧值 </span><br></pre></td></tr></table></figure>\n<p>优化后时间复杂度不变， 空间复杂度O(m)</p>\n<h2 id=\"相似题目\">相似题目</h2>\n<ul>\n<li><a href=\"\">装箱问题</a></li>\n<li><a href=\"\"> </a></li>\n</ul>\n","feature":true,"text":"题目描述 有 N件物品和一个容量是V的背包。每件物品只能使用一次。 第i件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过...","permalink":"/post/1 0-1背包","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":6,"path":"api/categories/算法.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/tags/动态规划.json"},{"name":"背包","slug":"背包","count":6,"path":"api/tags/背包.json"},{"name":"模板题","slug":"模板题","count":5,"path":"api/tags/模板题.json"},{"name":"easy","slug":"easy","count":4,"path":"api/tags/easy.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">题目描述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\">输出样例</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">原题链接</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">解题思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E4%BC%BC%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">相似题目</span></a></li></ol>","author":{"name":"尤一","slug":"blog-author","avatar":"img/cat.jpg","link":"/","description":"社畜码农，热爱设计，热爱编程，热爱生活。","socials":{"github":"https://github.com/StayOne1","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"2 装箱问题","uid":"30e42fe6a21da7424094456c2b5a974a","slug":"2 装箱问题","date":"2025-03-04T16:00:00.000Z","updated":"2025-03-07T14:18:19.888Z","comments":true,"path":"api/articles/2 装箱问题.json","keywords":null,"cover":null,"text":"题目描述 有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积。 现在从 n 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个...","permalink":"/post/2 装箱问题","photos":[],"count_time":{"symbolsCount":830,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":6,"path":"api/categories/算法.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/tags/动态规划.json"},{"name":"背包","slug":"背包","count":6,"path":"api/tags/背包.json"},{"name":"easy","slug":"easy","count":4,"path":"api/tags/easy.json"}],"author":{"name":"尤一","slug":"blog-author","avatar":"img/cat.jpg","link":"/","description":"社畜码农，热爱设计，热爱编程，热爱生活。","socials":{"github":"https://github.com/StayOne1","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"3 完全背包","uid":"6caea40c9fab236139a1dd0f7cc85795","slug":"3 完全背包","date":"2025-03-04T16:00:00.000Z","updated":"2025-03-07T14:18:35.157Z","comments":true,"path":"api/articles/3 完全背包.json","keywords":null,"cover":null,"text":"题目描述 有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。 第 i 种物品的体积是 vi，价值是 wi 。 求解将哪些物品装入背包，可使这些物品...","permalink":"/post/3 完全背包","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":6,"path":"api/categories/算法.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":6,"path":"api/tags/动态规划.json"},{"name":"背包","slug":"背包","count":6,"path":"api/tags/背包.json"},{"name":"模板题","slug":"模板题","count":5,"path":"api/tags/模板题.json"},{"name":"easy","slug":"easy","count":4,"path":"api/tags/easy.json"}],"author":{"name":"尤一","slug":"blog-author","avatar":"img/cat.jpg","link":"/","description":"社畜码农，热爱设计，热爱编程，热爱生活。","socials":{"github":"https://github.com/StayOne1","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/","juejin":"","customs":{}}},"feature":true}}