[{"id":"6caea40c9fab236139a1dd0f7cc85795","title":"3 完全背包","content":"题目描述\n有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。\n第 i 种物品的体积是 vi，价值是 wi 。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。\n输入样例\n123454 51 22 43 44 5\n输出样例\n10\n原题链接\n\nAcWing\n\n\n解题思路\n考虑跟0-1背包一样的状态表示， 但要主要这里的物品可以无限去选， 因此在做状态转移时需要枚举物品的个数K\n代码\n123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 1e3 + 10 ;int n , m ;int w[N] , v[N] ;int f[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    for(int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i] ;        for(int i = 1 ; i &lt;= n ; i++)&#123;        for(int j = 1 ; j &lt;= m ; j++)&#123;            f[i][j] = f[i-1][j];            for(int k = 1 ; j &gt;= w[i] * k ;k++)&#123;                f[i][j] = max(f[i][j] , f[i-1][j-w[i]*k] + v[i] * k);            &#125;        &#125;    &#125;    cout &lt;&lt; f[n][m];    return 0 ;&#125;\n\n复杂度较高，会超时\n优化1\n展开枚举，观察状态转移计算\n123456789记w[i] = w ,v[i] = if[i][j]   = max(f[i-1][j] , f[i-1][j-w]+v , f[i-1][j-2w]+2v , ...)f[i][j-w] = max(            f[i-1][j-w] , f[i-1][j-2w]+v , f[i-1][j-3w]+2v ,...)归纳发现, f[i][j] = max( f[i - 1][j], f[i][j - w] + v ) \n因此，可以不用枚举，直接用 j-w 的状态计算\n12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 1e3 + 10 ;int n , m ;int w[N] , v[N] ;int f[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    for(int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i] ;        for(int i = 1 ; i &lt;= n ; i++)&#123;        for(int j = 0 ; j &lt;= m ; j++)&#123;            f[i][j] = f[i-1][j];            if(j &gt;= w[i]) f[i][j] = max(f[i][j] , f[i][j - w[i] ] + v[i] );        &#125;    &#125;    cout &lt;&lt; f[n][m];    return 0 ;&#125;\n优化2\n类比0-1背包，二维转一维\n与01背包不同，完全背包的状态依赖是正上方和同一行的左边\n因此我们考虑正向遍历，从左到右更新数组\n12这样以来当我们计算到f[j]时，当前f[j]记录的是前一行的f[j]，f[j-w]是当前行的f[j]，如此覆盖就是合法的了\n123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 1e3 + 10 ;int n , m ;int w[N] , v[N] ;int f[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    for(int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i] ;        for(int i = 1 ; i &lt;= n ; i++)&#123;        for(int j = w[i] ; j &lt;= m ; j++)&#123;            f[j] = max(f[j] , f[j - w[i] ] + v[i] );        &#125;    &#125;    cout &lt;&lt; f[m];    return 0 ;&#125;\n相似题目\n\n \n \n\n","slug":"3 完全背包","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,模板题,easy","author_index":"尤一"},{"id":"30e42fe6a21da7424094456c2b5a974a","title":"2 装箱问题","content":"题目描述\n有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积。\n现在从 n 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。\n第一行共一个整数 V，表示箱子容量。\n第二行共一个整数 n，表示物品总数。\n接下来 n 行，每行有一个正整数，表示第 i 个物品的体积。\n输出一个整数，表示箱子最小剩余空间。\n输入样例\n124 6 8 3 12 7 9 7\n输出样例\n10\n原题链接\n\nAcWing提高\n\n\n解题思路\n0-1 背包变体， 考虑物品的代价和价值都是物品的体积， 则\n求箱子的最小剩余空间就转化为求所装物品的最大价值\n1结果 = 箱子容量v - f[n][m]\n代码\n1234567891011121314151617181920212223242526#include&lt;iostream&gt; #include&lt;algorithm&gt;using namespace std ;const int N = 2e4+10 ;int v[N] ;int f[N][N]  ;int main()&#123;\t\tint m , n ; //容量m n个物品 \tcin &gt;&gt; m &gt;&gt; n ;\tfor (int i = 1 ; i &lt;= n; i++)\t\tcin &gt;&gt; v[i] ; //物品体积价值 \t\tfor(int i = 1;i&lt;=n;i++)&#123;\t\tfor(int j = 0 ;j&lt;=m;j++)&#123; //j从0 1 开始都可以 \t\t\tf[i][j]=f[i-1][j] ;\t\t\tif(j&gt;=v[i]) f[i][j] = max(f[i][j],f[i-1][j-v[i]]+v[i]);\t\t&#125;\t&#125;\t\tcout&lt;&lt;m - f[n][m] ;\t\treturn 0 ;&#125;\n\n","slug":"2 装箱问题","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,easy","author_index":"尤一"},{"id":"6cf5ad84fc4af74989856ae444b292c5","title":"1 0-1背包","content":"题目描述\n有 N件物品和一个容量是V的背包。每件物品只能使用一次。\n第i件物品的体积是 vi，价值是 wi。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。\n输入样例\n123454 51 22 43 44 5\n输出样例\n18\n原题链接\n\nAcwing\n\n\n解题思路\n状态表示：\n123状态是 当背包容量为 j 时， 前 i 个物品的选法。 f[i][j] 表示在所有选法中，背包所装物品的最大价值\n状态转移：\n12考虑到 容量为j，前i个物品的所有选法 = &#123;包含物品i ， 不包含物品i&#125;f[i][j] = max (f[i - 1][j] , f[i - 1][j - w[i]] + v[i])\n注意到，并不是所有的容量 j 都对应以上转移方程，当容量 j 小于 第 i 个物品的代价时 ，就减少了一种包含物品 i 的状态 ，因此并不需要计算max函数\n代码\n123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 1e3+10 ;int n,m;int f[N][N];int w[N],v[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;        for(int i = 1 ; i &lt;= n ;i++) scanf(&quot;%d%d&quot; , &amp;w[i],&amp;v[i]);        for(int i = 1 ; i &lt;= n ;i++)&#123;        for(int j = 1 ; j &lt;= m ;j++)&#123;            f[i][j] = f[i-1][j] ;            if(j &gt;= w[i]) f[i][j] = max(f[i][j] , f[i-1][j-w[i]] + v[i]);        &#125;    &#125;    cout &lt;&lt; f[n][m];    return 0;\t&#125;\n算法的时间复杂度 O( n * m ) , 空间复杂度 O( n * m )     注意实际代码的dp数组开了N * N\n\n优化\n考虑将二维数组优化为一维\n123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 1e3+10 ;int n,m;int f[N]; // f[N][N]int w[N],v[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;        for(int i = 1 ; i &lt;= n ;i++) scanf(&quot;%d%d&quot; , &amp;w[i],&amp;v[i]);        for(int i = 1 ; i &lt;= n ;i++)&#123;        for(int j = m ; j &gt;= w[i] ;j--)&#123;            //f[i][j] = f[i-1][j] ;            //if(j &gt;= w[i]) f[i][j] = max(f[i][j] , f[i-1][j-w[i]] + v[i]);            f[j] = max(f[j] , f[j-w[i]] + v[i]);        &#125;    &#125;    cout &lt;&lt; f[m];    return 0;&#125;\n为什么可以用一维数组呢？\n12345考虑计算状态转移方程时 f[i][j] 的依赖关系 ，只可能依赖于上一行f[i - 1]的两个位置 即正上方f[i - 1][j] 和 左上方 f[i - 1][j - w[i]]因此， 我们考虑一种变算变覆盖的可能， 我们用一维数组进行记录， 并保证从右到左更新数组， 这样一来， 我们在计算f[j]时， f[j - w[i]]仍然保持前一行的旧值 \n优化后时间复杂度不变， 空间复杂度O(m)\n相似题目\n\n装箱问题\n \n\n","slug":"1 0-1背包","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,模板题,easy","author_index":"尤一"},{"id":"e71b3566dd243deeb08fd2064b960ce7","title":"4 多重背包1","content":"题目描述\n有 N种物品和一个容量是 V的背包。\n第 i种物品最多有 ai 件，每件体积是 vi，价值是 wi。\n求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。\n输出最大价值。\n第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。\n接下来有 NN 行，每行三个整数 vi,wi,ai，用空格隔开，分别表示第 i种物品的体积、价值和数量。\n输出一个整数，表示最大价值。\n输入样例\n123454 51 2 32 4 13 4 34 5 2\n输出样例\n10\n原题链接\n\nAcWing\n\n\n解题思路\n代码\n123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 110 ;int n, m ;int w[N], v[N], a[N];int f[N][N] ;int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    for(int i = 1 ; i &lt;= n ; i++) scanf(&quot;%d%d%d&quot;,&amp;w[i],&amp;v[i],&amp;a[i]);        for (int i = 1 ; i &lt;= n; i++)\t\tfor (int j = 0; j &lt;= m; j++ )\t\t\tfor (int k = 0; k &lt;= a[i] &amp;&amp; k * w[i] &lt;= j ;k++)\t\t\t\tf[i][j] = max(f[i][j] , f[i-1][j-w[i]*k]+v[i]*k) ;\t\t\t\t\tcout&lt;&lt; f[n][m] &lt;&lt;endl ;    return 0 ;&#125;\n\n","slug":"4 多重背包1","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,模板题,easy","author_index":"尤一"},{"id":"c5422bd2de84a2c9973c0e0db8b986a4","title":"6 多重背包3","content":"题目描述\n有 N种物品和一个容量是 V的背包。\n第 i种物品最多有 si件，每件体积是 vi，价值是 wi。\n求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。\n输出最大价值。\n输入格式\n第一行两个整数，N，V(0&lt;N≤10000&lt;V≤20000)，用空格隔开，分别表示物品种数和背包容积。\n接下来有 N行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i种物品的体积、价值和数量。\n输出格式\n输出一个整数，表示最大价值。\n数据范围\n0&lt;N≤1000\n0&lt;V≤20000\n0&lt;vi,wi,si≤20000\n提示\n本题考查多重背包的单调队列优化方法。\n输入样例\n123454 51 2 32 4 13 4 34 5 2\n输出样例\n110\n原题链接\n\nAcWing\n\n\n解题思路\n代码\n1234567#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;\treturn 0;&#125;\n\n相似题目\n\n \n \n\n","slug":"6 多重背包3","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,模板题,hard","author_index":"尤一"},{"id":"6d915df24433f6304d7bd51f422e5996","title":"5 多重背包2","content":"题目描述\n同[[4 多重背包1]]\n数据范围\n0&lt;N≤1000\n0&lt;V≤2000\n0&lt;vi,wi,si≤2000\n输入样例\n同[[4 多重背包1]]\n输出样例\n同[[4 多重背包1]]\n原题链接\n\nAcWing\n\n\n解题思路\n考虑将多重背包问题转化为0-1背包问题求解。\n多重背包问题中，每类物品可能有s件，我们可以将其直接视为有S个(代价价值相同但性质不同的物品)，这样以来，n类物品就转化为了n * si （si不一定相等，就不展开了）个物品。那么就转化为了0-1背包问题，但是问题来了，本题的数据范围较大，n * si * m &gt; 4e8 ，一定会超时\n如何优化？\n我们考虑不将各类物品完全展开，可以将一类物品分组，例如一类物品有11个的话，可以分成1+2+4+4 个 ，这样以来， 我们的si就从11 变为了 4 ， 复杂度可以降为logn 级别，总复杂度就可以降低到 1000 * 11 * 2000 = 2e7 ，就不会TLE了\n为什么可以这么分？\n这种优化方式称为二进制优化。我们知道n位二进制数可以表示出 2的n次方 种状态，状态也就是我们这里的物品。所以11我们需要用4位二进制来表示，log向上取整。但其实4位二进制可以表示16重状态，有些是我们用不到的。因此最后一组的值是我们一个一个减出来的（详见代码）\n为什么分组后可以按照0-1背包做，dp顺序仍然跟0-1背包一样？\n这个问题也是困扰我的一个问题，我能理解1，2，4，4 可以组合出0~11的状态，但是这里的状态组合并不一定是连续的呀，也有可能跳着，比如1+4 = 5，就隔开了2\n后来想明白了，可能是因为我们0-1背包直接按着一维写出来，突然就不太理解了，可以还原到二维去理解，其实不需要担心这个问题，dp在过程中已经考虑了所有的情况并且给出了当前状态的最优解了。（这是笔者自己的thinking，不太懂的可以看看参考资料里博主的描述，再看看y总的视频讲解，会有自己的理解的）\n代码\n12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 2e4+10 , M = 2010 ;int n, m;int w[N], v[N], f[M]; //笔者习惯用w表示代价，v表示价值int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    int cnt= 0;//计数，统计拆分的组数，用于遍历    for(int i = 1 ; i &lt;= n; i++)&#123;        int wi,vi,ai;        scanf(&quot;%d%d%d&quot;,&amp;wi,&amp;vi,&amp;ai);        for(int k = 1 ; ai - k &gt;=0 ; k *= 2)&#123;            cnt++;            w[cnt] = wi * k;            v[cnt] = vi * k;            ai -= k ;        &#125;        if(ai != 0 )&#123;            cnt++;            w[cnt] = ai * wi;            v[cnt] = ai * vi;        &#125;    &#125;        for(int i = 1 ; i &lt;= cnt ; i++)&#123;//0-1背包的一维写法        for(int j = m ; j &gt;= w[i] ; j--)&#123;            f[j] = max (f[j] , f[j - w[i]] + v[i]);        &#125;    &#125;        cout &lt;&lt; f[m];    return 0;        &#125;\n下面给出Y总的写法，用vector可以不用计数\n12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std ;const int N = 2010 ;int n, m;int f[N];struct Good&#123;\tint w,v;&#125;;int main()&#123;\tvector&lt;Good&gt; goods;    cin &gt;&gt; n &gt;&gt; m;        for(int i = 0 ; i &lt; n; i++)&#123;        int wi,vi,ai;        scanf(&quot;%d%d%d&quot;,&amp;wi,&amp;vi,&amp;ai);                for(int k = 1 ; ai - k &gt;=0 ; k *= 2)&#123;\t        goods.push_back(&#123;wi * k, vi * k&#125;);            ai -= k ;        &#125;        if(ai != 0 )&#123;\t\t\tgoods.push_back(&#123;wi * ai, vi * ai&#125;);        &#125;    &#125;        for(auto good: goods)&#123;        for(int j = m ; j &gt;= good.w ; j--)&#123;            f[j] = max (f[j] , f[j - good.w] + good.v);        &#125;    &#125;        cout &lt;&lt; f[m];    return 0;        &#125;\n\n参考资料\n\nAcWing 5. 二进制优化，它为什么正确，为什么合理，凭什么可以这样分？？\nAcWing 5. 多重背包问题 II \nY总视频讲解\n\n","slug":"5 多重背包2","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,模板题,medium","author_index":"尤一"}]