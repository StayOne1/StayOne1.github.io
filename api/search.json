[{"id":"30e42fe6a21da7424094456c2b5a974a","title":"2 装箱问题","content":"题目描述\n有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积。\n现在从 n 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。\n第一行共一个整数 V，表示箱子容量。\n第二行共一个整数 n，表示物品总数。\n接下来 n 行，每行有一个正整数，表示第 i 个物品的体积。\n输出一个整数，表示箱子最小剩余空间。\n输入样例\n124 6 8 3 12 7 9 7\n输出样例\n10\n原题链接\n\nAcWing提高\n\n\n解题思路\n0-1 背包变体， 考虑物品的代价和价值都是物品的体积， 则\n求箱子的最小剩余空间就转化为求所装物品的最大价值\n1结果 = 箱子容量v - f[n][m]\n代码\n1234567891011121314151617181920212223242526#include&lt;iostream&gt; #include&lt;algorithm&gt;using namespace std ;const int N = 2e4+10 ;int v[N] ;int f[N][N]  ;int main()&#123;\t\tint m , n ; //容量m n个物品 \tcin &gt;&gt; m &gt;&gt; n ;\tfor (int i = 1 ; i &lt;= n; i++)\t\tcin &gt;&gt; v[i] ; //物品体积价值 \t\tfor(int i = 1;i&lt;=n;i++)&#123;\t\tfor(int j = 0 ;j&lt;=m;j++)&#123; //j从0 1 开始都可以 \t\t\tf[i][j]=f[i-1][j] ;\t\t\tif(j&gt;=v[i]) f[i][j] = max(f[i][j],f[i-1][j-v[i]]+v[i]);\t\t&#125;\t&#125;\t\tcout&lt;&lt;m - f[n][m] ;\t\treturn 0 ;&#125;\n\n","slug":"2 装箱问题","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,easy","author_index":"尤一"},{"id":"6caea40c9fab236139a1dd0f7cc85795","title":"3 完全背包","content":"题目描述\n有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。\n第 i 种物品的体积是 vi，价值是 wi 。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。\n输入样例\n123454 51 22 43 44 5\n输出样例\n10\n原题链接\n\nAcWing\n\n\n解题思路\n考虑跟0-1背包一样的状态表示， 但要主要这里的物品可以无限去选， 因此在做状态转移时需要枚举物品的个数K\n代码\n123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 1e3 + 10 ;int n , m ;int w[N] , v[N] ;int f[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    for(int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i] ;        for(int i = 1 ; i &lt;= n ; i++)&#123;        for(int j = 1 ; j &lt;= m ; j++)&#123;            f[i][j] = f[i-1][j];            for(int k = 1 ; j &gt;= w[i] * k ;k++)&#123;                f[i][j] = max(f[i][j] , f[i-1][j-w[i]*k] + v[i] * k);            &#125;        &#125;    &#125;    cout &lt;&lt; f[n][m];    return 0 ;&#125;\n\n复杂度较高，会超时\n优化1\n展开枚举，观察状态转移计算\n123456789记w[i] = w ,v[i] = if[i][j]   = max(f[i-1][j] , f[i-1][j-w]+v , f[i-1][j-2w]+2v , ...)f[i][j-w] = max(            f[i-1][j-w] , f[i-1][j-2w]+v , f[i-1][j-3w]+2v ,...)归纳发现, f[i][j] = max( f[i - 1][j], f[i][j - w] + v ) \n因此，可以不用枚举，直接用 j-w 的状态计算\n12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 1e3 + 10 ;int n , m ;int w[N] , v[N] ;int f[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    for(int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i] ;        for(int i = 1 ; i &lt;= n ; i++)&#123;        for(int j = 0 ; j &lt;= m ; j++)&#123;            f[i][j] = f[i-1][j];            if(j &gt;= w[i]) f[i][j] = max(f[i][j] , f[i][j - w[i] ] + v[i] );        &#125;    &#125;    cout &lt;&lt; f[n][m];    return 0 ;&#125;\n优化2\n类比0-1背包，二维转一维\n与01背包不同，完全背包的状态依赖是正上方和同一行的左边\n因此我们考虑正向遍历，从左到右更新数组\n12这样以来当我们计算到f[j]时，当前f[j]记录的是前一行的f[j]，f[j-w]是当前行的f[j]，如此覆盖就是合法的了\n123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 1e3 + 10 ;int n , m ;int w[N] , v[N] ;int f[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    for(int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i] ;        for(int i = 1 ; i &lt;= n ; i++)&#123;        for(int j = w[i] ; j &lt;= m ; j++)&#123;            f[j] = max(f[j] , f[j - w[i] ] + v[i] );        &#125;    &#125;    cout &lt;&lt; f[m];    return 0 ;&#125;\n相似题目\n\n \n \n\n","slug":"3 完全背包","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,模板题,easy","author_index":"尤一"},{"id":"6cf5ad84fc4af74989856ae444b292c5","title":"1 0-1背包","content":"题目描述\n有 N件物品和一个容量是V的背包。每件物品只能使用一次。\n第i件物品的体积是 vi，价值是 wi。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。\n输入样例\n123454 51 22 43 44 5\n输出样例\n18\n原题链接\n\nAcwing\n\n\n解题思路\n状态表示：\n123状态是 当背包容量为 j 时， 前 i 个物品的选法。 f[i][j] 表示在所有选法中，背包所装物品的最大价值\n状态转移：\n12考虑到 容量为j，前i个物品的所有选法 = &#123;包含物品i ， 不包含物品i&#125;f[i][j] = max (f[i - 1][j] , f[i - 1][j - w[i]] + v[i])\n注意到，并不是所有的容量 j 都对应以上转移方程，当容量 j 小于 第 i 个物品的代价时 ，就减少了一种包含物品 i 的状态 ，因此并不需要计算max函数\n代码\n123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 1e3+10 ;int n,m;int f[N][N];int w[N],v[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;        for(int i = 1 ; i &lt;= n ;i++) scanf(&quot;%d%d&quot; , &amp;w[i],&amp;v[i]);        for(int i = 1 ; i &lt;= n ;i++)&#123;        for(int j = 1 ; j &lt;= m ;j++)&#123;            f[i][j] = f[i-1][j] ;            if(j &gt;= w[i]) f[i][j] = max(f[i][j] , f[i-1][j-w[i]] + v[i]);        &#125;    &#125;    cout &lt;&lt; f[n][m];    return 0;\t&#125;\n算法的时间复杂度 O( n * m ) , 空间复杂度 O( n * m )     注意实际代码的dp数组开了N * N\n\n优化\n考虑将二维数组优化为一维\n123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 1e3+10 ;int n,m;int f[N]; // f[N][N]int w[N],v[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;        for(int i = 1 ; i &lt;= n ;i++) scanf(&quot;%d%d&quot; , &amp;w[i],&amp;v[i]);        for(int i = 1 ; i &lt;= n ;i++)&#123;        for(int j = m ; j &gt;= w[i] ;j--)&#123;            //f[i][j] = f[i-1][j] ;            //if(j &gt;= w[i]) f[i][j] = max(f[i][j] , f[i-1][j-w[i]] + v[i]);            f[j] = max(f[j] , f[j-w[i]] + v[i]);        &#125;    &#125;    cout &lt;&lt; f[m];    return 0;&#125;\n为什么可以用一维数组呢？\n12345考虑计算状态转移方程时 f[i][j] 的依赖关系 ，只可能依赖于上一行f[i - 1]的两个位置 即正上方f[i - 1][j] 和 左上方 f[i - 1][j - w[i]]因此， 我们考虑一种变算变覆盖的可能， 我们用一维数组进行记录， 并保证从右到左更新数组， 这样一来， 我们在计算f[j]时， f[j - w[i]]仍然保持前一行的旧值 \n优化后时间复杂度不变， 空间复杂度O(m)\n相似题目\n\n装箱问题\n \n\n","slug":"1 0-1背包","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,模板题,easy","author_index":"尤一"},{"id":"e71b3566dd243deeb08fd2064b960ce7","title":"4 多重背包1","content":"题目描述\n有 N种物品和一个容量是 V的背包。\n第 i种物品最多有 ai 件，每件体积是 vi，价值是 wi。\n求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。\n输出最大价值。\n第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。\n接下来有 NN 行，每行三个整数 vi,wi,ai，用空格隔开，分别表示第 i种物品的体积、价值和数量。\n输出一个整数，表示最大价值。\n输入样例\n123454 51 2 32 4 13 4 34 5 2\n输出样例\n10\n原题链接\n\nAcWing\n\n\n解题思路\n代码\n123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 110 ;int n, m ;int w[N], v[N], a[N];int f[N][N] ;int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    for(int i = 1 ; i &lt;= n ; i++) scanf(&quot;%d%d%d&quot;,&amp;w[i],&amp;v[i],&amp;a[i]);        for (int i = 1 ; i &lt;= n; i++)\t\tfor (int j = 0; j &lt;= m; j++ )\t\t\tfor (int k = 0; k &lt;= a[i] &amp;&amp; k * w[i] &lt;= j ;k++)\t\t\t\tf[i][j] = max(f[i][j] , f[i-1][j-w[i]*k]+v[i]*k) ;\t\t\t\t\tcout&lt;&lt; f[n][m] &lt;&lt;endl ;    return 0 ;&#125;\n\n","slug":"4 多重背包1","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,模板题,easy","author_index":"尤一"},{"id":"6d915df24433f6304d7bd51f422e5996","title":"5 多重背包2","content":"题目描述\n同[[4 多重背包1]]\n数据范围\n0&lt;N≤1000\n0&lt;V≤2000\n0&lt;vi,wi,si≤2000\n输入样例\n同[[4 多重背包1]]\n输出样例\n同[[4 多重背包1]]\n原题链接\n\nAcWing\n\n\n解题思路\n考虑将多重背包问题转化为0-1背包问题求解。\n多重背包问题中，每类物品可能有s件，我们可以将其直接视为有S个(代价价值相同但性质不同的物品)，这样以来，n类物品就转化为了n * si （si不一定相等，就不展开了）个物品。那么就转化为了0-1背包问题，但是问题来了，本题的数据范围较大，n * si * m &gt; 4e8 ，一定会超时\n如何优化？\n我们考虑不将各类物品完全展开，可以将一类物品分组，例如一类物品有11个的话，可以分成1+2+4+4 个 ，这样以来， 我们的si就从11 变为了 4 ， 复杂度可以降为logn 级别，总复杂度就可以降低到 1000 * 11 * 2000 = 2e7 ，就不会TLE了\n为什么可以这么分？\n这种优化方式称为二进制优化。我们知道n位二进制数可以表示出 2的n次方 种状态，状态也就是我们这里的物品。所以11我们需要用4位二进制来表示，log向上取整。但其实4位二进制可以表示16重状态，有些是我们用不到的。因此最后一组的值是我们一个一个减出来的（详见代码）\n为什么分组后可以按照0-1背包做，dp顺序仍然跟0-1背包一样？\n这个问题也是困扰我的一个问题，我能理解1，2，4，4 可以组合出0~11的状态，但是这里的状态组合并不一定是连续的呀，也有可能跳着，比如1+4 = 5，就隔开了2\n后来想明白了，可能是因为我们0-1背包直接按着一维写出来，突然就不太理解了，可以还原到二维去理解，其实不需要担心这个问题，dp在过程中已经考虑了所有的情况并且给出了当前状态的最优解了。（这是笔者自己的thinking，不太懂的可以看看参考资料里博主的描述，再看看y总的视频讲解，会有自己的理解的）\n代码\n12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 2e4+10 , M = 2010 ;int n, m;int w[N], v[N], f[M]; //笔者习惯用w表示代价，v表示价值int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    int cnt= 0;//计数，统计拆分的组数，用于遍历    for(int i = 1 ; i &lt;= n; i++)&#123;        int wi,vi,ai;        scanf(&quot;%d%d%d&quot;,&amp;wi,&amp;vi,&amp;ai);        for(int k = 1 ; ai - k &gt;=0 ; k *= 2)&#123;            cnt++;            w[cnt] = wi * k;            v[cnt] = vi * k;            ai -= k ;        &#125;        if(ai != 0 )&#123;            cnt++;            w[cnt] = ai * wi;            v[cnt] = ai * vi;        &#125;    &#125;        for(int i = 1 ; i &lt;= cnt ; i++)&#123;//0-1背包的一维写法        for(int j = m ; j &gt;= w[i] ; j--)&#123;            f[j] = max (f[j] , f[j - w[i]] + v[i]);        &#125;    &#125;        cout &lt;&lt; f[m];    return 0;        &#125;\n下面给出Y总的写法，用vector可以不用计数\n12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std ;const int N = 2010 ;int n, m;int f[N];struct Good&#123;\tint w,v;&#125;;int main()&#123;\tvector&lt;Good&gt; goods;    cin &gt;&gt; n &gt;&gt; m;        for(int i = 0 ; i &lt; n; i++)&#123;        int wi,vi,ai;        scanf(&quot;%d%d%d&quot;,&amp;wi,&amp;vi,&amp;ai);                for(int k = 1 ; ai - k &gt;=0 ; k *= 2)&#123;\t        goods.push_back(&#123;wi * k, vi * k&#125;);            ai -= k ;        &#125;        if(ai != 0 )&#123;\t\t\tgoods.push_back(&#123;wi * ai, vi * ai&#125;);        &#125;    &#125;        for(auto good: goods)&#123;        for(int j = m ; j &gt;= good.w ; j--)&#123;            f[j] = max (f[j] , f[j - good.w] + good.v);        &#125;    &#125;        cout &lt;&lt; f[m];    return 0;        &#125;\n\n参考资料\n\nAcWing 5. 二进制优化，它为什么正确，为什么合理，凭什么可以这样分？？\nAcWing 5. 多重背包问题 II \nY总视频讲解\n\n","slug":"5 多重背包2","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,模板题,medium","author_index":"尤一"},{"id":"c5422bd2de84a2c9973c0e0db8b986a4","title":"6 多重背包3","content":"题目描述\n有 N种物品和一个容量是 V的背包。\n第 i种物品最多有 si件，每件体积是 vi，价值是 wi。\n求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。\n输出最大价值。\n输入格式\n第一行两个整数，N，V(0&lt;N≤10000&lt;V≤20000)，用空格隔开，分别表示物品种数和背包容积。\n接下来有 N行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i种物品的体积、价值和数量。\n输出格式\n输出一个整数，表示最大价值。\n数据范围\n0&lt;N≤1000\n0&lt;V≤20000\n0&lt;vi,wi,si≤20000\n提示\n本题考查多重背包的单调队列优化方法。\n输入样例\n123454 51 2 32 4 13 4 34 5 2\n输出样例\n110\n原题链接\n\nAcWing\n\n\n解题思路\n代码\n1234567#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;\treturn 0;&#125;\n\n相似题目\n\n \n \n\n","slug":"6 多重背包3","date":"2025-03-04T16:00:00.000Z","categories_index":"算法","tags_index":"动态规划,背包,模板题,hard","author_index":"尤一"},{"id":"a3e841aae6c2b2f6d824263a309c7163","title":"数论基础-质数相关基础算法","content":"质数\n什么是质数（素数）\n质数就是一个大于1的整数，除了1和它本身以外，不能被其他自然数整除\n注意：1、0不是质数 质数是从2开始的\n一些简单的性质\n\n质数x的约数只有1和x;\n任何一个正整数，要么是质数，要么可以分解为几个质数的积(唯一);\n质数定理 ： 1~n 中有 n/lnN 个质数\n\n判定一个数是否是质数\n试除法\n\n\n最简单的试除法  O(n)\nx的约数只能是1~x,如果x是质数，那么除了1和x不能被其他数整除\n很明显这个算法最坏会是O(n)的复杂度，但是显然实际运算不会达到这个复杂度，我们待会儿来分析一下\n 12345678bool is_prime(int n )&#123; if(n&lt;2) return false; for(int i=2;i&lt;n;i++)&#123;     if(n%i==0)         return false; &#125; return true;&#125;\n\n\n做一些简单的优化 0(n) --&gt; O(sqrt(n))\n上一个算法整体的思路是正确的，瓶颈在于n的大小，因为它最坏是0(n)的复杂度，那我们考虑优化就要从这个角度入手，看是否能够减少循环判断的次数。\n然后我们就会发现，其实根本不需要遍历到n-1。我们都知道X = sqrt(X)^2 , 那么很明显，当其中一个因数缩小，另外一个因数必然增大。由于我们考虑的是正整数范围，所以不存在因数是分数的情况，也就是说因数不能无限制缩小，最小应该是1。\n那么我们就只用关注1~sqrt(X) 这个范围，因为另外一半里必然跟前一半一一对应。\n所以这个算法就优化成了这样\n 12345678bool is_prime(int n )&#123; if(n&lt;2) return false; for(int i=2;i&lt; = n/i;i++)&#123;     if(n%i==0)         return false; &#125; return true;&#125;\n其实，大家可能已经发现了，其实这个循环的上限不是关键，关键是循环内的判断，因为一旦被整除，其实这个函数就已经返回false了。循环从2开始走，如果有约数，必然在2~sqrt(X)中有约数\n\n\n分解质因数\n试除法    O(logn) ~ O(sqrt(n))\n算法思想\n使用试除法，当遍历到可以整除的i时，让i循环除n并记录次数，然后输出质因子i和其次数ai\n最后如果n有剩余且大于1，就直接输出n和其次数1\n代码如下:\n1234567891011121314151617//从小到大枚举所有数 n中最多只包含一个大于sqrt(n)的质因子void divide(int n)&#123; for(int i = 2;i &lt;= n/i;i++)&#123;     if(n%i==0)&#123;         int s = 0;         while(n%i==0)&#123;             n/=i;             s++;         &#125;         printf(&quot;%d %d\\n&quot;,i,s);     &#125;      &#125; if( n &gt; 1) printf(&quot;%d %d\\n&quot;,n,1); puts(&quot;&quot;);&#125;\n为什么是这样的？\n 首先，我们要知道n中最多只包含一个大于sqrt(n)的质因子，这个可以用反证法来证明，假如说存在两个大于sqrt(n)的质因子，那么两个质因子的一次方乘积就已经大于n了，故至多存在1个大于sqrt(n)的质因子。\n我们举一个例子，n=33  \n33 = 3^1 * 11^1 ,也就是33的质因子是3和11，11是大于根号33的\n好，明白了这一点，我们就能明白为什么循环条件是到sqrt(n)，为什么最后还要再判断n&gt;1。我们在不断除质数的过程中其实n已经越来越小了，如果n是1说明已经恰好除尽。否则，就说明n还剩了一个大于根号n的质因子，那么我们直接输出就可以了。\n\n截止现在，我们学习了如何判断一个数是否是质数以及如何将一个数分解成为若干质因子的积\n那么，假设我现在需要知道1~n中质数的个数，怎么办呢？当然，你可以双层for循环解决，但如果n比较大呢？将近n^2的复杂度是不是有点儿高呢，那怎么办呢？\n下面我们就要来说这个问题\n筛质数\n筛质数要解决的问题就是快速求出n以内质数的个数\n\n\n朴素筛\n算法思想\n既然用除法作试除法一个一个判断太耗时了，那我们可以反其道而行之，我们不用除法，改用乘法去把每个数的倍数筛掉，因为如果n是x的倍数，那么n必然就不是质数，因为它至少有x这个约数\n我们用这个思想就可以从2开始遍历，把每个数的倍数筛掉。\n具体实现\n在具体的实现中，我们是这么来做的。定义primes[N]存放质数，cnt累加质数的个数，st[N]用来标记一个数是否被筛掉，筛掉为true\n我们开始遍历，首先如果当前这个数没有被筛掉，那么它就是一个质数，我们把它放到primes中，然后累加。\n然后我们将n以内i的所有倍数筛掉\n这样这个算法就完成了\n12345678910111213//朴素筛 O(nlogn)const int N = 1000010 ;int primes[N] , cnt;bool st[N] ;void get_primes(int n)&#123; for(int i = 2;i&lt;=n;i++)&#123;     if(!st[i])&#123;         primes[cnt++]=i;     &#125;     for(int j = i+i;j&lt;=n;j+=i) st[j] = true ; &#125;&#125;\n或许大家已经发现了，是否有一些数被多个i重复筛掉了，这里我们举一个简单的例子：8 = 2^3,很显然8会被2、4重复筛。\n接下来我们再来考虑一下如何去进一步的优化\n\n\n埃氏筛法\n优化策略\n其实只需要让n的质因子把n筛掉即可，如果i不是质数就不需要再筛i的倍数，大家可以思考一下。比如8=2^3,i=2就可以筛掉8，当i=4时，i其实是一个合数，就不用筛了，因为4的倍数一定也是2的倍数。\n1234567891011121314//质数定理 ： 1~n 中有 n/lnN 个质数 //优化--&gt; O(nloglogn)  const int N = 1000010 ;int primes[N] , cnt;bool st[N] ;void get_primes(int n)&#123; for(int i = 2;i&lt;=n;i++)&#123;     if(!st[i])&#123;         primes[cnt++]=i;         for(int j = i+i;j&lt;=n;j+=i) st[j] = true ;     &#125; &#125;&#125;\n那么可能大家又会想到，n会不会被多个质因子重复筛掉呢，想到这里，那博主真的要羡慕的哭出来了，毕竟当时想到这些的都是计算机界的dalao\n线性筛法就是为了解决这个问题！\n\n\n线性筛法\n优化策略\n让每一个合数都只被自己的最小质因子筛掉\n 1234567891011121314151617181920212223//线性筛法  10^7//n 只会被其最小质因子筛掉const int N = 1000010 ;int primes[N] , cnt;bool st[N] ;void get_primes(int n)&#123;    for(int i = 2;i&lt;=n;i++)&#123;        if(!st[i]) primes[cnt++]=i;        for(int j = 0;primes[j] &lt;=n / i; j++ )&#123;            st[primes[j]*i] = true ;            if(i%primes[j] == 0) break; //primes[j]一定是i的最小质因子，        &#125;    &#125;&#125;分析循环体1. i%pj == 0    pj一定是i的最小质因子，pj一定是i * pj 的最小质因子2. i%pj!=0    pj一定小于i的所有质因子，pj也一定是i * pj的最小质因子所以说一个合数只会被自己的最小质因子筛掉\n\n","slug":"数论基础-质数相关基础算法","date":"2022-09-15T16:00:00.000Z","categories_index":"算法","tags_index":"算法,数论","author_index":"尤一"},{"id":"7972c32d39f314ccb6f804289f8a291c","title":"Git基础","content":"Git学习\nGit 是一个分布式版本控制系统，可以便捷高效地处理任何项目。Git的内容存储使用的是SHA-1哈希算法。\nGit 工作流程\n\n克隆 Git 资源作为工作目录。\n在克隆的资源上添加或修改文件。\n如果其他人修改了，你可以更新资源。\n在提交前查看修改。\n提交修改。\n在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。\n\n\nGit工作区、暂存区、版本库\n\n工作区： 就是你在电脑里能看到的目录\n暂存区： (index) 一般存放在.git目录下的index文件中，也叫做索引\n版本库： 工作区一个隐藏目录.git\n\n\n\n创建版本库\n\n\n创建文件夹\nmkdir 文件夹名\n\n\n切换到某目录下\ncd 文件夹名\n\n\n查看当前目录\npwd\n\n\n把当前目录初始化到仓库\ngit init\n\n\n添加文件到仓库 可以添加多个文件\ngit add 文件名\n\n\n提交到仓库\ngit commit -m &quot;解释&quot;\n\n\n时光机\n\n当前仓库状态(本地)\ngit status\n查看文件上次修改记录\ngit diff 文件名\n\n版本回退\n\n显示最近到最远的提交日志\ngit log\n简易显示\ngit log --pretty=oneline\n\n\n\n\n\n\n\n\n\n\nHEAD表示当前版本，HEAD^表示上一版本\nHEAD^^表示上上版本，HEAD~100表示上100个版本\n\n\nHEAD也可以换成是对应版本的前部分版本号\ngit reset --hard HEAD^\n\n\n记录了每一次命令\ngit reflog\n\n\n\n连接远程仓库\n\n\n生成ssh密钥\n 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; \n生成的密钥默认位于C:\\Users\\用户名.ssh文件夹中 默认文件名为id_rsa\n\n\n建立与github的连接\n进入用户settings ，选择ssh and GPG keys,创建一个ssh密钥，把公钥(.pub)粘贴进去\n\n\n连接远程仓库\n在github中创建项目仓库，并复制仓库ssh链接  通常为git@github.com:xxx/xxx.git\n在本地仓库进入git bash ，运行命令git remote add origin git@github.com:xxx/xxx.git\n\n\npull操作\ngit pull --rebase origin 分支名\n\n\npush操作\ngit push -u origin 分支名\n\n\n","slug":"Git基础","date":"2022-09-02T16:00:00.000Z","categories_index":"Git","tags_index":"Git","author_index":"尤一"},{"id":"6fc8774f334f99b8964d2d8c2cdc313c","title":"SQL","content":"这个主要是整理之前学习时的笔记 持续更新 欢迎大家留言 批评指正\nSQL\nSQL通用语法\n\n\nSQL语句可以单行或多行书写，以分号结尾。\n\n\n可以使用空格和缩进提高可读性。\n\n\nMySQL中SQL语句不区分大小写，关键字建议大写。\n\n\n3种注释\n\n\n单行注释\n12-- 注释内容# 注释内容\n\n\n多行注释\n123/*注释*/\n\n\n\n\nDDL语句\nDDL（Data Definition Language）数据定义语言，用来定义数据库对象“数据库，表，列等。关键字：create,drop,alter等\n\n\n操作数据库：CRUD\n\n\nC(Create):创建\n\n\nR(Retrieve):查询\n\n\nU(Update):修改\n\n\nD(Delete):删除\n\n\n使用数据库\n123456789101112131415161718192021222324252627282930#创建基本创建create database 数据库名;如果不存在，再进行创建create database if not exists 数据库名;指定字符集create database 数据库名 character set 字符集;#查询查询所有数据库的名称show databases;查看某数据库创建语句show create database 数据库名称;#修改修改数据库的字符集alter database 数据库名 character set 字符集名;#删除删除数据库drop database 数据库名称;判断是否存在drop database if exists 数据库名字;#使用查询当前正在使用的数据库select database();切换到对应数据库use 数据库名;\n\n\n\n\n操作表：CRUD\n1234567891011121314151617181920212223242526272829303132#创建创建表create table 表名(\t列名1 数据类型1,    列名2 数据类型2,    ...    列名n 数据类型n);复制表create table 表名 like 表名;#查询查询某个数据库中所有的表名称show tables;查询表结构desc 表名;#修改修改表名alter table 表名 rename to 新表名;修改表的字符集alter table 表名 character set 字符集;添加列alter table 表名 add 列名 数据类型;修改列名、类型alter table 表名 change 列名 新列名 类型;只修改列类型alter table 表名 modify 列名 列类型;删除列alter table 表名 drop 列名;#删除drop table 表名;drop table if exists 表名;\n\n\nDQL语句\nDQL(Data Query Language)数据查询语言 用来查询数据库中表的记录。关键字：select,where等\n\n基础查询  字段名后可以加 [AS] 别名\n条件查询  条件运算符 between … and …    and   or\n分组查询\n排序查询  升序ASC 降序DESC\n分页查询 起始索引（从0开始），每页展示记录数\n\n\n\n基础查询\n\n\n多个字段的查询\n\n\n去除重复\n\n\n计算列\n\n\n起别名\n12345678910#多个字段的查询select 字段1,字段2,...,字段n from 表名;select * from 表名;#去除重复select distinct 字段名 from 表名;#计算列，数值型select 字段1,字段2,字段1+字段2 from 表名;select 字段1,字段2,字段1+IFNULL(字段2,0) from 表名; //当某字段值为null时#起别名select 字段1,字段2,字段1+IFNULL(字段2,0) AS(可以省略) 总分 from 表名; \n\n\n\n\n条件查询\n\n\nwhere 子句后跟条件\n\n\n运算符\n1234567891011121314#whereselect 字段名 from 表名 where 条件;#运算符&lt; &gt; &lt;= &gt;= == &lt;&gt;(!=)between and likeis nulland 或 &amp;&amp;or 或 ||not 或 !in#注意NULL值不能使用运算符判断  要用iswhere 字段名 is null\n\n\n\n\n模糊查询\n12345#占位符_:单个任意字符%:多个任意字符#语法select 字段 from 表名 where 字段名 like ;\n\n\n排序查询\n12345678#语法order by 排序字段1 排序方式1,...,排序字段n 排序方式n;排序方式省略时默认按照升序排序#排序方式ASC：升序，默认DESC：降序#多字段优先级语句前面的字段更优先\n\n\n聚合函数(将一列数据纵向计算)\n\n\ncount:计算个数\n\n\nmax:计算最大值\n\n\nmin:计算最小值\n\n\nsum:求和\n\n\navg:平均值\n12345678910111213#countselect count(*) from 表名;select count(字段名) from 表名;字段可以使用IFNULL转换#maxselect max(字段名) from 表名;#minselect min(字段名) from 表名;#sumselect sum(字段名) from 表名;#avg#注意聚合函数的计算，排除NULL值\n\n\n\n\n分组查询\n123456789101112#语法group by 分组字段;#注意分组之后查询的字段：分组字段、聚合函数#分组前过滤，即不参与分组select 字段 from 表名 where 条件 group by 字段;#分组后过滤select 字段 from 表名 group by 字段 having 条件;#where 和 having 的区别where 在分组之前进行限定，如果不满足条件，则不参与分组。 having 在分组之后进行限定，如果不满足结果，则不会被查询出来。where 后不可以跟聚合函数，having可以进行聚合函数的判断\n\n\n分页查询\n123456#语法limit 开始的索引,每页查询的条数;#公式开始的索引 = (当前页码-1)*每页显示的条数#分页操作是一个方言，不同数据库存在区别limit是mysql的\n\n\nDQL-编写顺序\n  1234567891011121314SELECT      字段列表FROM      表名列表WHERE      条件列表 #分组之前过滤GROUP BY      分组字段列表HAVING      分组后条件列表 #分组之后过滤ORDER BY       排序字段列表LIMIT      分页参数\n\nDQL-执行顺序\n  1234567891011121314FROM      表名列表WHERE      条件列表GROUP BY      分组字段列表HAVING      分组后条件列表SELECT      字段列表ORDER BY      排序字段列表LIMIT      分页参数\nDCL语句\n\n\nDCL-介绍\nDCL-数据控制语言，用来管理数据库用户以及用户对数据库的访问权限,关键字：GRANT,REVOKE等\n\n\nDCL-管理用户\n\n\n查询用户\n1234USE mysql; SELLECT * FROM user;#注意%指可以在任意主机登录\n\n\n创建用户\n1CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;\n\n\n修改用户密码\n1234567891011ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password by &#x27;新密码&#x27;;#root改其它update user set password = password(&#x27;新密码&#x27;) where user = &#x27;用户名&#x27;;set password for &#x27;用户名&#x27;@&#x27;主机名&#x27; = password(&#x27;新密码&#x27;);#mysql 忘记root密码1. cmd -- &gt; net stop mysql  //管理员2. 使用无验证方式启动Mysql服务  mysqld --skip-grant-tables3. 新开cmd然后直接输入mysql 回车 无验证登录后修改密码4. 任务管理器结束mysqld进程5. 打开mysql服务 net start mysql6. 正常登录\n\n\n删除用户\n123DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;#权限说明usage ： 可以登录\n\n\n\n\nDCL-授权\n\n\n查询权限\n1show grants for &#x27;用户名&#x27;@&#x27;主机名&#x27;;\n\n\n授予权限\n123grant 权限列表 on 数据库.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;#授予所有权限grant all on *.* to &#x27;用户名&#x27;@&#x27;主机名&#x27;;\n\n\n撤销权限\n1revoke 权限列表 on 数据库.表名 from &#x27;用户名&#x27;@&#x27;主机名&#x27;;\n\n\n\n\nDBA：数据库管理员\n\n\nDML语句\nDML(Data Manipulation Language)数据操作语言 用来对表中的数据进行增删查改。关键字：insert,delete,update等\n\n\n添加数据\n\n\n删除数据\n\n\n修改数据\n1234567891011121314151617#添加数据insert into 表名(列名1,列名2,...,列名n) values(值1,值2,...,值n);列名要和值一一对应如果不指定列名，则默认给所有列添加值除了数字，其他都要用引号引起来，单双引号都可以#删除数据delete from 表名 [where 条件];如果不加条件，则删除表中所有的记录如果要删除表中所有记录，有两种方式。不推荐使用delete，效率低。建议使用后者。删除表，然后再创建一个一模一样的空表TRUNCATE TABLE 表名;#修改数据update 表名 set 列名1 = 值1,... [where 条件];如果不加任何条件，则会修改所有记录\n\n\n约束\n概念 ： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。\n分类 ：\n\n\n主键约束：primary key\n\n\n非空约束：not null\n\n\n唯一约束：unique\n\n\n外键约束：foreign key\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#主键约束,非空且唯一，一张表只能有一个主键主键即表中记录的唯一标识创建表时添加约束Create table stu&#123;\tid int primary key,\tname varchar(10) &#125;;创建表后添加约束alter table 表名 modify 字段名 字段类型 primary key;删除约束alter table 表名 drop primary key;自动增长，如果某一列是数值类型，可以使用auto_increment 可以自动增长创建表时添加约束，并使其自动增长Create table stu&#123;\tid int primary key auto_increment,\tname varchar(10) &#125;;删除自动增长，并不会删除主键alter table 表名 modify 字段名 字段类型;添加自动增长alter table 表名 modify 字段名 字段类型 auto_increment;#非空约束创建表时添加约束Create table stu&#123;\tid int,\tname varchar(10) not null&#125;;创建表后添加非空约束alter table 表名 modify 字段名 字段类型 not null;删除非空约束alter table 表名 modify 字段名 字段类型;#唯一约束,值不能重复创建表时添加约束Create table stu&#123;\tid int,\tname varchar(10) unique&#125;;创建表后添加约束alter table 表名 modify 字段名 字段类型 unique;删除约束alter table 表名 drop index 字段名;注意唯一约束可以有null，但只能有一个为null#外键约束,让表与表产生关系创建表时，可以添加外键create table 表名&#123;\t...\t外键列,\tconstraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)&#125;;删除外键alter table 表名 drop foreign key 外键名称;创建表后，添加外键alter table 表名 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称);#级联添加外键，设置级联更新alter table 表名 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) on update cascade;设置级联删除on delete cascade\n\n\n数据库的设计\n多表关系\n\n\n一对一(了解)\n如：人和身份证\n分析：一个人只有一个身份证，一个身份证只能对应一个人\n\n\n一对多(多对一)\n如：部门和员工\n分析：一个部门有多个员工，一个员工只能对应一个部门\n\n\n多对多\n如：学生和课程\n分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择\n\n\n12345678#实现#一对多关系实现设计两个表，使用外键实现。在多的一方建立外键，指向一的一方的主键。#实现多对多关系借助第三张表，中间表(t_xx_xx)。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。#一对一关系任意一方建立外键，指向另一方的主键。外键添加唯一约束。\n数据库设计的范式\n概念：设计数据库时，需要遵循的一些规范。各种范式呈递次规范，越高的范式数据库冗余越小。要遵循后边的范式，必须先遵循前边的所有范式要求。\n目前关系数据库有六种范式：第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)、第五范式(5NF)\n分类：\n\n\n第一范式：每一列都是不可分割的原子数据项。\n存在的问题：\n\n\n存在严重的数据冗余\n\n\n数据添加时存在问题\n\n\n删除数据时存在问题\n\n\n\n\n第二范式：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）\n概念：\n\n函数依赖：A–&gt;B，如果通过A属性(属性组)的值，可以确定唯一B属性的值，则称B依赖于A\n\n学号 --&gt; 姓名\n(学号，课程名称) --&gt; 分数\n\n\n完全函数依赖：A --&gt; B ，如果A是一个属性组，则B属性值的确定需要依赖A属性组中所有属性的值\n\n(学号，课程名称) --&gt; 分数\n\n\n部分函数依赖：A–&gt;B ，如果A是一个属性组，则B属性值只需要依赖A中某一些值即可\n\n(学号，课程名称) --&gt; 姓名\n\n\n传递函数依赖：A–&gt;B B–&gt;C   如果通过A属性(属性组)的值，可以确定唯一B属性的值，再通过B属性(属性组)的值，可以确定唯一C属性的值，则称C传递函数依赖于A\n码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码。\n\n(学号，课程名称)\n\n\n主属性：码属性组中的所有属性\n非主属性：除码属性组的属性\n\n\n\n​\t3. 第三范式：在2NF的基础上，任何非主属性不依赖于其他非主属性(在2NF基础上消除传递依赖)\n数据库的备份和还原\n\n\n命令行方式\n1234567#备份mysqldump -u用户名 -p密码 数据库名 &gt; 保存的路径    //路径包含文件名后缀#还原登录创建数据库使用数据库执行文件 source 文件路径\n\n\n图形化工具\n\n\n多表查询\n笛卡尔积\n\n\n内连接查询\n\n隐式内连接：使用where条件消除无用数据\n显式内连接：123456789101112131415161718      #隐式内连接查询      select 字段 from 表1,表2 where 表一.字段名 运算符 表二.字段名;      #显示内连接      select 字段 from 表1 [inner] join 表2 on 条件;      #注意      从哪些表中查询数据、查询条件是什么、查询哪些字段2. 外连接查询   1. 左外连接：查询的是左表所有数据以及其交集部分   2. 右外连接：查询的是右表所有数据以及其交集部分      ```sql      #左外连接      select 字段列表 from 表1 left [outer] join 表2 on 条件;      #右外连接      select 字段列表 from 表1 right [outer] join 表2 on 条件;\n\n\n\n\n子查询\n概念： 查询中嵌套查询，称嵌套查询为子查询\n分类：\n\n\n子查询的结果是单行单列的：\n12子查询可以作为条件 使用运算符去判断select 字段列表 from 表名 where 字段 运算符 (子查询语句);\n\n\n子查询的结果是多行单列的；\n1select 字段列表 from 表名 where 字段 in (子查询语句);\n\n\n子查询的结果是多行多列的。\n子查询可以作为一张虚拟表，起一个别名\n1select 字段列表 from 表1 别名,(子查询语句) 别名 where 条件;\n\n\n\n\n事务\n事务的基本介绍\n概念：如果一个包含多个步骤的业务操作，被事务管理，要么同时成功，要么同时失败。\n操作：\n1. 开启事务：start transaction\n1. 回滚：rollback\n1. 提交：commit\n\nMyQL数据库中事务默认自动提交。开启事务后需要手动提交。Oracle默认是手动提交\n修改事务的默认提交方式：\nselect @@autocommit; – 0是手动提交 1是自动提交\nset @@autocommit = 对应数值;\n事务的四大特征\n\n原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败\n持久性：如果事务一旦提交或者回滚后，数据库会持久化的保存数据。\n隔离性：多个事务之间，相互独立\n一致性：事务操作前后，数据总量不变。\n\n事务的隔离级别\n概念：多个事务之间是隔离，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。\n存在问题：\n1. 脏读：一个事务，读取到另一个事务中没有提交的数据\n1. 不可重复读：在同一个事务中，两次读取到的数据不一样\n1. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改\n\n隔离级别：\n\n\nread uncommitted：读未提交\n产生的问题：脏读、不可重复读、幻读\n\n\nread committed：读已提交（Oracle默认）\n产生的问题：不可重复读、幻读\n\n\nrepeatable read：可重复读（MySQL默认）\n产生的：幻读\n\n\nserializable：串行化\n产生的问题：可以解决所有的问题\n\n\n​\t注意：隔离级别从小到大安全性越来越高，但是效率越来越低\n​\t设置隔离级别:\n1234#数据库查询隔离级别select @@tx_isolation#数据库设置隔离级别set global transaction isolation level 级别字符串;\nMySQL\nmysql服务的启动与关闭\n使用管理员身份在控制台输入\nnet start/stop mysql\n","slug":"sql","date":"2022-08-31T16:00:00.000Z","categories_index":"数据库","tags_index":"sql","author_index":"尤一"},{"id":"d8c5cdf794b98a3ee47186f592b0c059","title":"JAVA设计模式之装饰模式","content":"装饰模式\n装饰器模式是为了在不改变原有类的结构的前提下，给一个现有的对象拓展新的功能。这种类型的设计模式属于结构性模式，它作为现有类的一个包装。\n这种模式为拓展类提供了新的解决方案，可以不使用继承的方式实现。\n\n优点：\n\n可以代替继承，减少子类的数量\n动态增加功能，动态撤销\n\n缺点：\n\n多层装饰比较复杂\n\n\n装饰模式的基本结构\n装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。\n装饰模式类图如下：\n\n装饰模式中的角色有：\n\n抽象构件(Component) ： 给出一个抽象接口，以规范准备接收附加责任的对象。\n具体构件(ConcreteComponent) : 定义一个将要接收附加责任的类。\n装饰角色(Decerator) : 持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。\n具体装饰(ConcreteDecorator)角色 : 负责给构件对象“贴上”附加的责任。\n\n源代码：\n抽象构件：\n12345public interface Component &#123;        public void sampleOperation();    &#125;\n具体构件 ：\n123456public class ConcreteComponent implements Component &#123;    @Override    public void sampleOperation() &#123;        // 写相关的业务代码    &#125;&#125;\n装饰角色：\n1234567891011121314public class Decorator implements Component&#123;    private Component component;        public Decorator(Component component)&#123;        this.component = component;    &#125;    @Override    public void sampleOperation() &#123;        // 委派给构件        component.sampleOperation();    &#125;    &#125;\n具体装饰角色：\n1234567891011public class ConcreteDecoratorA extends Decorator &#123;    public ConcreteDecoratorA(Component component) &#123;        super(component);    &#125;        @Override    public void sampleOperation() &#123;　　　　　super.sampleOperation();        // 写相关的业务代码    &#125;&#125;\n\n齐天大圣的例子\n类图 ：\n\n\n装饰模式是Java I/O的基本模式\n由于Java I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。而如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是Java I/O库的基本模式。\nInputStream的对象结构图如下：\n\n根据上图可以看出：\n\n\nComponent：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。\n\n\nConcreteComponent：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。\n\n\nDecorator：由FilterInputStream扮演。它实现了InputStream所规定的接口。\n\n\nConcreteDecorator：由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。\n\n\nBufferedReader\n类图：\n\n在其设计中Readable是抽象构件，Reader则是一个装饰角色，BufferedReader是具体装饰角色，对Reader对象进行了包装。BufferedReader内定义了readLine、fill等方法，使用字符数组作为缓冲区，进而提高读入速度，同时提供了便捷的toString方法，可以直接返回字符串。\n\n参考文章：\n设计模式详解——装饰者模式\n菜鸟教程\n刘java\n","slug":"JAVA设计模式之装饰模式","date":"2022-08-30T16:00:00.000Z","categories_index":"JAVA","tags_index":"JAVA","author_index":"尤一"}]